// GENERATED CODE - DO NOT EDIT
// This file was generated by protoc-gen-fastmarshal

package storage

import (
	"fmt"
	"sync/atomic"
	"github.com/CrowdStrike/csproto"
)

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for GoogleProviderMetadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *GoogleProviderMetadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Project (string,optional)
	if l = len(m.Project); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ClusterName (string,optional)
	if l = len(m.ClusterName); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *GoogleProviderMetadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *GoogleProviderMetadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Project (1,string,optional)
	if len(m.Project) > 0 {
		enc.EncodeString(1, m.Project)
	}
	// ClusterName (2,string,optional)
	if len(m.ClusterName) > 0 {
		enc.EncodeString(2, m.ClusterName)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *GoogleProviderMetadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Project (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'project' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'project' (tag=1): %w", err)
			} else {
				m.Project = s
			}

		case 2: // ClusterName (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'cluster_name' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'cluster_name' (tag=2): %w", err)
			} else {
				m.ClusterName = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AWSProviderMetadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AWSProviderMetadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// AccountId (string,optional)
	if l = len(m.AccountId); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AWSProviderMetadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AWSProviderMetadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// AccountId (1,string,optional)
	if len(m.AccountId) > 0 {
		enc.EncodeString(1, m.AccountId)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AWSProviderMetadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // AccountId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'account_id' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'account_id' (tag=1): %w", err)
			} else {
				m.AccountId = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AzureProviderMetadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AzureProviderMetadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// SubscriptionId (string,optional)
	if l = len(m.SubscriptionId); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AzureProviderMetadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AzureProviderMetadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// SubscriptionId (1,string,optional)
	if len(m.SubscriptionId) > 0 {
		enc.EncodeString(1, m.SubscriptionId)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AzureProviderMetadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // SubscriptionId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'subscription_id' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'subscription_id' (tag=1): %w", err)
			} else {
				m.SubscriptionId = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ProviderMetadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ProviderMetadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Region (string,optional)
	if l = len(m.Region); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Zone (string,optional)
	if l = len(m.Zone); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Verified (bool,optional)
	if m.Verified {
		sz += csproto.SizeOfTagKey(15) + 1
	}

	// Provider (oneof)
	if m.Provider != nil {
		switch typedVal := m.Provider.(type) {
		case *ProviderMetadata_Google: // google (3,message)
			l = csproto.Size(typedVal.Google)
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
		case *ProviderMetadata_Aws: // aws (4,message)
			l = csproto.Size(typedVal.Aws)
			sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
		case *ProviderMetadata_Azure: // azure (5,message)
			l = csproto.Size(typedVal.Azure)
			sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ProviderMetadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ProviderMetadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Region (1,string,optional)
	if len(m.Region) > 0 {
		enc.EncodeString(1, m.Region)
	}
	// Zone (2,string,optional)
	if len(m.Zone) > 0 {
		enc.EncodeString(2, m.Zone)
	}
	// Verified (15,bool,optional)
	if m.Verified {
		enc.EncodeBool(15, m.Verified)
	}
	// Provider (oneof)

	if m.Provider != nil {
		switch typedVal := m.Provider.(type) {
		case *ProviderMetadata_Google: // google (3,message)
			enc.EncodeNested(3, typedVal.Google)
		case *ProviderMetadata_Aws: // aws (4,message)
			enc.EncodeNested(4, typedVal.Aws)
		case *ProviderMetadata_Azure: // azure (5,message)
			enc.EncodeNested(5, typedVal.Azure)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ProviderMetadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Region (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'region' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'region' (tag=1): %w", err)
			} else {
				m.Region = s
			}

		case 2: // Zone (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'zone' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'zone' (tag=2): %w", err)
			} else {
				m.Zone = s
			}

		case 15: // Verified (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'verified' (tag=15), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'verified' (tag=15): %w", err)
			} else {
				m.Verified = v
			}

		case 3: // Provider.google (oneof,message)
			var ov ProviderMetadata_Google
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'google' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm_google GoogleProviderMetadata
			if err = dec.DecodeNested(&mm_google); err != nil {
				return fmt.Errorf("unable to decode message value for field 'google' (tag=3): %w", err)
			} else {
				ov.Google = &mm_google
			}
			m.Provider = &ov
		case 4: // Provider.aws (oneof,message)
			var ov ProviderMetadata_Aws
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'aws' (tag=4), expected 2 (length-delimited)", wt)
			}
			var mm_aws AWSProviderMetadata
			if err = dec.DecodeNested(&mm_aws); err != nil {
				return fmt.Errorf("unable to decode message value for field 'aws' (tag=4): %w", err)
			} else {
				ov.Aws = &mm_aws
			}
			m.Provider = &ov
		case 5: // Provider.azure (oneof,message)
			var ov ProviderMetadata_Azure
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'azure' (tag=5), expected 2 (length-delimited)", wt)
			}
			var mm_azure AzureProviderMetadata
			if err = dec.DecodeNested(&mm_azure); err != nil {
				return fmt.Errorf("unable to decode message value for field 'azure' (tag=5): %w", err)
			} else {
				ov.Azure = &mm_azure
			}
			m.Provider = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for OrchestratorMetadata

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *OrchestratorMetadata) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Version (string,optional)
	if l = len(m.Version); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ApiVersions (string,repeated)
	for _, sv := range m.ApiVersions {
		l = len(sv)
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}

	// IsOpenshift (oneof)
	if m.IsOpenshift != nil {
		switch typedVal := m.IsOpenshift.(type) {
		case *OrchestratorMetadata_OpenshiftVersion: // openshift_version (4,string)
			l = len(typedVal.OpenshiftVersion)
			sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *OrchestratorMetadata) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *OrchestratorMetadata) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Version (1,string,optional)
	if len(m.Version) > 0 {
		enc.EncodeString(1, m.Version)
	}
	// ApiVersions (3,string,repeated)
	for _, val := range m.ApiVersions {
		enc.EncodeString(3, val)
	}
	// IsOpenshift (oneof)

	if m.IsOpenshift != nil {
		switch typedVal := m.IsOpenshift.(type) {
		case *OrchestratorMetadata_OpenshiftVersion: // openshift_version (4,string)
			enc.EncodeString(4, typedVal.OpenshiftVersion)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *OrchestratorMetadata) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Version (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'version' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'version' (tag=1): %w", err)
			} else {
				m.Version = s
			}

		case 3: // ApiVersions (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'api_versions' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'api_versions' (tag=3): %w", err)
			} else {
				m.ApiVersions = append(m.ApiVersions, s)
			}

		case 4: // is_openshift.openshift_version (oneof,string)
			var ov OrchestratorMetadata_OpenshiftVersion
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for tag field 'openshift_version' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'openshift_version' (tag=4): %w", err)
			} else {
				ov.OpenshiftVersion = s
			}
			m.IsOpenshift = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AdmissionControllerConfig

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AdmissionControllerConfig) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Enabled (bool,optional)
	if m.Enabled {
		sz += csproto.SizeOfTagKey(1) + 1
	}
	// TimeoutSeconds (int32,optional)
	if m.TimeoutSeconds != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.TimeoutSeconds))
	}
	// ScanInline (bool,optional)
	if m.ScanInline {
		sz += csproto.SizeOfTagKey(3) + 1
	}
	// DisableBypass (bool,optional)
	if m.DisableBypass {
		sz += csproto.SizeOfTagKey(4) + 1
	}
	// EnforceOnUpdates (bool,optional)
	if m.EnforceOnUpdates {
		sz += csproto.SizeOfTagKey(5) + 1
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AdmissionControllerConfig) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AdmissionControllerConfig) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Enabled (1,bool,optional)
	if m.Enabled {
		enc.EncodeBool(1, m.Enabled)
	}
	// TimeoutSeconds (2,int32,optional)
	if m.TimeoutSeconds != 0 {
		enc.EncodeInt32(2, m.TimeoutSeconds)
	}
	// ScanInline (3,bool,optional)
	if m.ScanInline {
		enc.EncodeBool(3, m.ScanInline)
	}
	// DisableBypass (4,bool,optional)
	if m.DisableBypass {
		enc.EncodeBool(4, m.DisableBypass)
	}
	// EnforceOnUpdates (5,bool,optional)
	if m.EnforceOnUpdates {
		enc.EncodeBool(5, m.EnforceOnUpdates)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AdmissionControllerConfig) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Enabled (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'enabled' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'enabled' (tag=1): %w", err)
			} else {
				m.Enabled = v
			}
		case 2: // TimeoutSeconds (int32,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'timeout_seconds' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'timeout_seconds' (tag=2): %w", err)
			} else {
				m.TimeoutSeconds = v
			}
		case 3: // ScanInline (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'scan_inline' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'scan_inline' (tag=3): %w", err)
			} else {
				m.ScanInline = v
			}
		case 4: // DisableBypass (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'disable_bypass' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'disable_bypass' (tag=4): %w", err)
			} else {
				m.DisableBypass = v
			}
		case 5: // EnforceOnUpdates (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'enforce_on_updates' (tag=5), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'enforce_on_updates' (tag=5): %w", err)
			} else {
				m.EnforceOnUpdates = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for TolerationsConfig

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *TolerationsConfig) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Disabled (bool,optional)
	if m.Disabled {
		sz += csproto.SizeOfTagKey(1) + 1
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *TolerationsConfig) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *TolerationsConfig) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Disabled (1,bool,optional)
	if m.Disabled {
		enc.EncodeBool(1, m.Disabled)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *TolerationsConfig) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Disabled (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'disabled' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'disabled' (tag=1): %w", err)
			} else {
				m.Disabled = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for StaticClusterConfig

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *StaticClusterConfig) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Type (enum,optional)
	if m.Type != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Type))
	}
	// MainImage (string,optional)
	if l = len(m.MainImage); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CentralApiEndpoint (string,optional)
	if l = len(m.CentralApiEndpoint); l > 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CollectionMethod (enum,optional)
	if m.CollectionMethod != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.CollectionMethod))
	}
	// CollectorImage (string,optional)
	if l = len(m.CollectorImage); l > 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// AdmissionController (bool,optional)
	if m.AdmissionController {
		sz += csproto.SizeOfTagKey(6) + 1
	}
	// AdmissionControllerUpdates (bool,optional)
	if m.AdmissionControllerUpdates {
		sz += csproto.SizeOfTagKey(7) + 1
	}
	// TolerationsConfig (message,optional)
	if m.TolerationsConfig != nil {
		l = csproto.Size(m.TolerationsConfig)
		sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// SlimCollector (bool,optional)
	if m.SlimCollector {
		sz += csproto.SizeOfTagKey(9) + 1
	}
	// AdmissionControllerEvents (bool,optional)
	if m.AdmissionControllerEvents {
		sz += csproto.SizeOfTagKey(10) + 1
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *StaticClusterConfig) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *StaticClusterConfig) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Type (1,enum,optional)
	if m.Type != 0 {
		enc.EncodeInt32(1, int32(m.Type))
	}
	// MainImage (2,string,optional)
	if len(m.MainImage) > 0 {
		enc.EncodeString(2, m.MainImage)
	}
	// CentralApiEndpoint (3,string,optional)
	if len(m.CentralApiEndpoint) > 0 {
		enc.EncodeString(3, m.CentralApiEndpoint)
	}
	// CollectionMethod (4,enum,optional)
	if m.CollectionMethod != 0 {
		enc.EncodeInt32(4, int32(m.CollectionMethod))
	}
	// CollectorImage (5,string,optional)
	if len(m.CollectorImage) > 0 {
		enc.EncodeString(5, m.CollectorImage)
	}
	// AdmissionController (6,bool,optional)
	if m.AdmissionController {
		enc.EncodeBool(6, m.AdmissionController)
	}
	// AdmissionControllerUpdates (7,bool,optional)
	if m.AdmissionControllerUpdates {
		enc.EncodeBool(7, m.AdmissionControllerUpdates)
	}
	// TolerationsConfig (8,message,optional)
	if m.TolerationsConfig != nil {
		if err = enc.EncodeNested(8, m.TolerationsConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'tolerations_config' (tag=8): %w", err)
		}
	}
	// SlimCollector (9,bool,optional)
	if m.SlimCollector {
		enc.EncodeBool(9, m.SlimCollector)
	}
	// AdmissionControllerEvents (10,bool,optional)
	if m.AdmissionControllerEvents {
		enc.EncodeBool(10, m.AdmissionControllerEvents)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *StaticClusterConfig) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=1): %w", err)
			} else {
				m.Type = ClusterType(v)
			}
		case 2: // MainImage (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'main_image' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'main_image' (tag=2): %w", err)
			} else {
				m.MainImage = s
			}

		case 3: // CentralApiEndpoint (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'central_api_endpoint' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'central_api_endpoint' (tag=3): %w", err)
			} else {
				m.CentralApiEndpoint = s
			}

		case 4: // CollectionMethod (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'collection_method' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'collection_method' (tag=4): %w", err)
			} else {
				m.CollectionMethod = CollectionMethod(v)
			}
		case 5: // CollectorImage (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'collector_image' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'collector_image' (tag=5): %w", err)
			} else {
				m.CollectorImage = s
			}

		case 6: // AdmissionController (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_controller' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'admission_controller' (tag=6): %w", err)
			} else {
				m.AdmissionController = v
			}
		case 7: // AdmissionControllerUpdates (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_controller_updates' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'admission_controller_updates' (tag=7): %w", err)
			} else {
				m.AdmissionControllerUpdates = v
			}
		case 8: // TolerationsConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'tolerations_config' (tag=8), expected 2 (length-delimited)", wt)
			}
			var mm TolerationsConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'tolerations_config' (tag=8): %w", err)
			}
			m.TolerationsConfig = &mm
		case 9: // SlimCollector (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'slim_collector' (tag=9), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'slim_collector' (tag=9): %w", err)
			} else {
				m.SlimCollector = v
			}
		case 10: // AdmissionControllerEvents (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_controller_events' (tag=10), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'admission_controller_events' (tag=10): %w", err)
			} else {
				m.AdmissionControllerEvents = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for DynamicClusterConfig

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *DynamicClusterConfig) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// AdmissionControllerConfig (message,optional)
	if m.AdmissionControllerConfig != nil {
		l = csproto.Size(m.AdmissionControllerConfig)
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// RegistryOverride (string,optional)
	if l = len(m.RegistryOverride); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// DisableAuditLogs (bool,optional)
	if m.DisableAuditLogs {
		sz += csproto.SizeOfTagKey(3) + 1
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *DynamicClusterConfig) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *DynamicClusterConfig) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// AdmissionControllerConfig (1,message,optional)
	if m.AdmissionControllerConfig != nil {
		if err = enc.EncodeNested(1, m.AdmissionControllerConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'admission_controller_config' (tag=1): %w", err)
		}
	}
	// RegistryOverride (2,string,optional)
	if len(m.RegistryOverride) > 0 {
		enc.EncodeString(2, m.RegistryOverride)
	}
	// DisableAuditLogs (3,bool,optional)
	if m.DisableAuditLogs {
		enc.EncodeBool(3, m.DisableAuditLogs)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *DynamicClusterConfig) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // AdmissionControllerConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'admission_controller_config' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm AdmissionControllerConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'admission_controller_config' (tag=1): %w", err)
			}
			m.AdmissionControllerConfig = &mm
		case 2: // RegistryOverride (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'registry_override' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'registry_override' (tag=2): %w", err)
			} else {
				m.RegistryOverride = s
			}

		case 3: // DisableAuditLogs (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'disable_audit_logs' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'disable_audit_logs' (tag=3): %w", err)
			} else {
				m.DisableAuditLogs = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for CompleteClusterConfig

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *CompleteClusterConfig) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// DynamicConfig (message,optional)
	if m.DynamicConfig != nil {
		l = csproto.Size(m.DynamicConfig)
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// StaticConfig (message,optional)
	if m.StaticConfig != nil {
		l = csproto.Size(m.StaticConfig)
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ConfigFingerprint (string,optional)
	if l = len(m.ConfigFingerprint); l > 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ClusterLabels (message,repeated)
	for k, v := range m.ClusterLabels {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		l = len(v)
		valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *CompleteClusterConfig) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *CompleteClusterConfig) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// DynamicConfig (1,message,optional)
	if m.DynamicConfig != nil {
		if err = enc.EncodeNested(1, m.DynamicConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'dynamic_config' (tag=1): %w", err)
		}
	}
	// StaticConfig (2,message,optional)
	if m.StaticConfig != nil {
		if err = enc.EncodeNested(2, m.StaticConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'static_config' (tag=2): %w", err)
		}
	}
	// ConfigFingerprint (3,string,optional)
	if len(m.ConfigFingerprint) > 0 {
		enc.EncodeString(3, m.ConfigFingerprint)
	}
	// ClusterLabels (4,map)
	for k, v := range m.ClusterLabels {
		valueSize := len(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(4, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeString(2, v)
	}

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *CompleteClusterConfig) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // DynamicConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'dynamic_config' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm DynamicClusterConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'dynamic_config' (tag=1): %w", err)
			}
			m.DynamicConfig = &mm
		case 2: // StaticConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'static_config' (tag=2), expected 2 (length-delimited)", wt)
			}
			var mm StaticClusterConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'static_config' (tag=2): %w", err)
			}
			m.StaticConfig = &mm
		case 3: // ConfigFingerprint (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'config_fingerprint' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'config_fingerprint' (tag=3): %w", err)
			} else {
				m.ConfigFingerprint = s
			}

		case 4: // ClusterLabels (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'cluster_labels' (tag=4), expected 2 (length-delimited)", wt)
			}

			if m.ClusterLabels == nil {
				m.ClusterLabels = make(map[string]string)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue string
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'cluster_labels' (tag=4), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'cluster_labels' (tag=4), expected 2 (length-delimited)", ewt)
					}
					if entryValue, err = dec.DecodeString(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.ClusterLabels[entryKey] = entryValue

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for SensorDeploymentIdentification

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *SensorDeploymentIdentification) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// SystemNamespaceId (string,optional)
	if l = len(m.SystemNamespaceId); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// DefaultNamespaceId (string,optional)
	if l = len(m.DefaultNamespaceId); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// AppNamespace (string,optional)
	if l = len(m.AppNamespace); l > 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// AppNamespaceId (string,optional)
	if l = len(m.AppNamespaceId); l > 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// AppServiceaccountId (string,optional)
	if l = len(m.AppServiceaccountId); l > 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// K8SNodeName (string,optional)
	if l = len(m.K8SNodeName); l > 0 {
		sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *SensorDeploymentIdentification) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *SensorDeploymentIdentification) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// SystemNamespaceId (1,string,optional)
	if len(m.SystemNamespaceId) > 0 {
		enc.EncodeString(1, m.SystemNamespaceId)
	}
	// DefaultNamespaceId (2,string,optional)
	if len(m.DefaultNamespaceId) > 0 {
		enc.EncodeString(2, m.DefaultNamespaceId)
	}
	// AppNamespace (3,string,optional)
	if len(m.AppNamespace) > 0 {
		enc.EncodeString(3, m.AppNamespace)
	}
	// AppNamespaceId (4,string,optional)
	if len(m.AppNamespaceId) > 0 {
		enc.EncodeString(4, m.AppNamespaceId)
	}
	// AppServiceaccountId (5,string,optional)
	if len(m.AppServiceaccountId) > 0 {
		enc.EncodeString(5, m.AppServiceaccountId)
	}
	// K8SNodeName (6,string,optional)
	if len(m.K8SNodeName) > 0 {
		enc.EncodeString(6, m.K8SNodeName)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *SensorDeploymentIdentification) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // SystemNamespaceId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'system_namespace_id' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'system_namespace_id' (tag=1): %w", err)
			} else {
				m.SystemNamespaceId = s
			}

		case 2: // DefaultNamespaceId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'default_namespace_id' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'default_namespace_id' (tag=2): %w", err)
			} else {
				m.DefaultNamespaceId = s
			}

		case 3: // AppNamespace (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'app_namespace' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'app_namespace' (tag=3): %w", err)
			} else {
				m.AppNamespace = s
			}

		case 4: // AppNamespaceId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'app_namespace_id' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'app_namespace_id' (tag=4): %w", err)
			} else {
				m.AppNamespaceId = s
			}

		case 5: // AppServiceaccountId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'app_serviceaccount_id' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'app_serviceaccount_id' (tag=5): %w", err)
			} else {
				m.AppServiceaccountId = s
			}

		case 6: // K8SNodeName (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'k8s_node_name' (tag=6), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'k8s_node_name' (tag=6): %w", err)
			} else {
				m.K8SNodeName = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for Cluster

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *Cluster) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Id (string,optional)
	if l = len(m.Id); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Name (string,optional)
	if l = len(m.Name); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Type (enum,optional)
	if m.Type != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.Type))
	}
	// Labels (message,repeated)
	for k, v := range m.Labels {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		l = len(v)
		valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		sz += csproto.SizeOfTagKey(27) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
	}

	// MainImage (string,optional)
	if l = len(m.MainImage); l > 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CollectorImage (string,optional)
	if l = len(m.CollectorImage); l > 0 {
		sz += csproto.SizeOfTagKey(16) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CentralApiEndpoint (string,optional)
	if l = len(m.CentralApiEndpoint); l > 0 {
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// RuntimeSupport (bool,optional)
	if m.RuntimeSupport {
		sz += csproto.SizeOfTagKey(7) + 1
	}
	// CollectionMethod (enum,optional)
	if m.CollectionMethod != 0 {
		sz += csproto.SizeOfTagKey(17) + csproto.SizeOfVarint(uint64(m.CollectionMethod))
	}
	// AdmissionController (bool,optional)
	if m.AdmissionController {
		sz += csproto.SizeOfTagKey(13) + 1
	}
	// AdmissionControllerUpdates (bool,optional)
	if m.AdmissionControllerUpdates {
		sz += csproto.SizeOfTagKey(21) + 1
	}
	// AdmissionControllerEvents (bool,optional)
	if m.AdmissionControllerEvents {
		sz += csproto.SizeOfTagKey(25) + 1
	}
	// Status (message,optional)
	if m.Status != nil {
		l = csproto.Size(m.Status)
		sz += csproto.SizeOfTagKey(15) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// DynamicConfig (message,optional)
	if m.DynamicConfig != nil {
		l = csproto.Size(m.DynamicConfig)
		sz += csproto.SizeOfTagKey(18) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TolerationsConfig (message,optional)
	if m.TolerationsConfig != nil {
		l = csproto.Size(m.TolerationsConfig)
		sz += csproto.SizeOfTagKey(19) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Priority (int64,optional)
	if m.Priority != 0 {
		sz += csproto.SizeOfTagKey(20) + csproto.SizeOfVarint(uint64(m.Priority))
	}
	// HealthStatus (message,optional)
	if m.HealthStatus != nil {
		l = csproto.Size(m.HealthStatus)
		sz += csproto.SizeOfTagKey(22) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// SlimCollector (bool,optional)
	if m.SlimCollector {
		sz += csproto.SizeOfTagKey(23) + 1
	}
	// HelmConfig (message,optional)
	if m.HelmConfig != nil {
		l = csproto.Size(m.HelmConfig)
		sz += csproto.SizeOfTagKey(24) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// MostRecentSensorId (message,optional)
	if m.MostRecentSensorId != nil {
		l = csproto.Size(m.MostRecentSensorId)
		sz += csproto.SizeOfTagKey(26) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// AuditLogState (message,repeated)
	for k, v := range m.AuditLogState {
		// size of key (always has an internal tag of 1)
		l = len(k)
		keySize := 1 + csproto.SizeOfVarint(uint64(l)) + l
		// size of value (always has an internal tag of 2)
		if v != nil {
			l = csproto.Size(v)
			valueSize := 1 + csproto.SizeOfVarint(uint64(l)) + l
			sz += csproto.SizeOfTagKey(28) + csproto.SizeOfVarint(uint64(keySize+valueSize)) + keySize + valueSize
		}
	}

	// InitBundleId (string,optional)
	if l = len(m.InitBundleId); l > 0 {
		sz += csproto.SizeOfTagKey(29) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ManagedBy (enum,optional)
	if m.ManagedBy != 0 {
		sz += csproto.SizeOfTagKey(30) + csproto.SizeOfVarint(uint64(m.ManagedBy))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *Cluster) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *Cluster) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Id (1,string,optional)
	if len(m.Id) > 0 {
		enc.EncodeString(1, m.Id)
	}
	// Name (2,string,optional)
	if len(m.Name) > 0 {
		enc.EncodeString(2, m.Name)
	}
	// Type (3,enum,optional)
	if m.Type != 0 {
		enc.EncodeInt32(3, int32(m.Type))
	}
	// Labels (27,map)
	for k, v := range m.Labels {
		valueSize := len(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(27, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeString(2, v)
	}

	// MainImage (4,string,optional)
	if len(m.MainImage) > 0 {
		enc.EncodeString(4, m.MainImage)
	}
	// CollectorImage (16,string,optional)
	if len(m.CollectorImage) > 0 {
		enc.EncodeString(16, m.CollectorImage)
	}
	// CentralApiEndpoint (5,string,optional)
	if len(m.CentralApiEndpoint) > 0 {
		enc.EncodeString(5, m.CentralApiEndpoint)
	}
	// RuntimeSupport (7,bool,optional)
	if m.RuntimeSupport {
		enc.EncodeBool(7, m.RuntimeSupport)
	}
	// CollectionMethod (17,enum,optional)
	if m.CollectionMethod != 0 {
		enc.EncodeInt32(17, int32(m.CollectionMethod))
	}
	// AdmissionController (13,bool,optional)
	if m.AdmissionController {
		enc.EncodeBool(13, m.AdmissionController)
	}
	// AdmissionControllerUpdates (21,bool,optional)
	if m.AdmissionControllerUpdates {
		enc.EncodeBool(21, m.AdmissionControllerUpdates)
	}
	// AdmissionControllerEvents (25,bool,optional)
	if m.AdmissionControllerEvents {
		enc.EncodeBool(25, m.AdmissionControllerEvents)
	}
	// Status (15,message,optional)
	if m.Status != nil {
		if err = enc.EncodeNested(15, m.Status); err != nil {
			return fmt.Errorf("unable to encode message data for field 'status' (tag=15): %w", err)
		}
	}
	// DynamicConfig (18,message,optional)
	if m.DynamicConfig != nil {
		if err = enc.EncodeNested(18, m.DynamicConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'dynamic_config' (tag=18): %w", err)
		}
	}
	// TolerationsConfig (19,message,optional)
	if m.TolerationsConfig != nil {
		if err = enc.EncodeNested(19, m.TolerationsConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'tolerations_config' (tag=19): %w", err)
		}
	}
	// Priority (20,int64,optional)
	if m.Priority != 0 {
		enc.EncodeInt64(20, m.Priority)
	}
	// HealthStatus (22,message,optional)
	if m.HealthStatus != nil {
		if err = enc.EncodeNested(22, m.HealthStatus); err != nil {
			return fmt.Errorf("unable to encode message data for field 'health_status' (tag=22): %w", err)
		}
	}
	// SlimCollector (23,bool,optional)
	if m.SlimCollector {
		enc.EncodeBool(23, m.SlimCollector)
	}
	// HelmConfig (24,message,optional)
	if m.HelmConfig != nil {
		if err = enc.EncodeNested(24, m.HelmConfig); err != nil {
			return fmt.Errorf("unable to encode message data for field 'helm_config' (tag=24): %w", err)
		}
	}
	// MostRecentSensorId (26,message,optional)
	if m.MostRecentSensorId != nil {
		if err = enc.EncodeNested(26, m.MostRecentSensorId); err != nil {
			return fmt.Errorf("unable to encode message data for field 'most_recent_sensor_id' (tag=26): %w", err)
		}
	}
	// AuditLogState (28,map)
	for k, v := range m.AuditLogState {
		if v == nil {
			continue
		}
		valueSize := csproto.Size(v)
		itemSize := 1 + csproto.SizeOfVarint(uint64(valueSize)) + valueSize
		keySize := len(k)
		itemSize += 1 + csproto.SizeOfVarint(uint64(keySize)) + keySize
		enc.EncodeMapEntryHeader(28, itemSize)
		enc.EncodeString(1, k)
		enc.EncodeNested(2, v)
	}

	// InitBundleId (29,string,optional)
	if len(m.InitBundleId) > 0 {
		enc.EncodeString(29, m.InitBundleId)
	}
	// ManagedBy (30,enum,optional)
	if m.ManagedBy != 0 {
		enc.EncodeInt32(30, int32(m.ManagedBy))
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *Cluster) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Id (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'id' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'id' (tag=1): %w", err)
			} else {
				m.Id = s
			}

		case 2: // Name (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'name' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'name' (tag=2): %w", err)
			} else {
				m.Name = s
			}

		case 3: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=3): %w", err)
			} else {
				m.Type = ClusterType(v)
			}
		case 27: // Labels (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'labels' (tag=27), expected 2 (length-delimited)", wt)
			}

			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue string
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'labels' (tag=27), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'labels' (tag=27), expected 2 (length-delimited)", ewt)
					}
					if entryValue, err = dec.DecodeString(); err != nil {
						return err
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.Labels[entryKey] = entryValue
		case 4: // MainImage (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'main_image' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'main_image' (tag=4): %w", err)
			} else {
				m.MainImage = s
			}

		case 16: // CollectorImage (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'collector_image' (tag=16), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'collector_image' (tag=16): %w", err)
			} else {
				m.CollectorImage = s
			}

		case 5: // CentralApiEndpoint (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'central_api_endpoint' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'central_api_endpoint' (tag=5): %w", err)
			} else {
				m.CentralApiEndpoint = s
			}

		case 7: // RuntimeSupport (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'runtime_support' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'runtime_support' (tag=7): %w", err)
			} else {
				m.RuntimeSupport = v
			}
		case 17: // CollectionMethod (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'collection_method' (tag=17), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'collection_method' (tag=17): %w", err)
			} else {
				m.CollectionMethod = CollectionMethod(v)
			}
		case 13: // AdmissionController (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_controller' (tag=13), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'admission_controller' (tag=13): %w", err)
			} else {
				m.AdmissionController = v
			}
		case 21: // AdmissionControllerUpdates (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_controller_updates' (tag=21), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'admission_controller_updates' (tag=21): %w", err)
			} else {
				m.AdmissionControllerUpdates = v
			}
		case 25: // AdmissionControllerEvents (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_controller_events' (tag=25), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'admission_controller_events' (tag=25): %w", err)
			} else {
				m.AdmissionControllerEvents = v
			}
		case 15: // Status (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'status' (tag=15), expected 2 (length-delimited)", wt)
			}
			var mm ClusterStatus
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'status' (tag=15): %w", err)
			}
			m.Status = &mm
		case 18: // DynamicConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'dynamic_config' (tag=18), expected 2 (length-delimited)", wt)
			}
			var mm DynamicClusterConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'dynamic_config' (tag=18): %w", err)
			}
			m.DynamicConfig = &mm
		case 19: // TolerationsConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'tolerations_config' (tag=19), expected 2 (length-delimited)", wt)
			}
			var mm TolerationsConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'tolerations_config' (tag=19): %w", err)
			}
			m.TolerationsConfig = &mm
		case 20: // Priority (int64,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'priority' (tag=20), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt64(); err != nil {
				return fmt.Errorf("unable to decode int64 value for field 'priority' (tag=20): %w", err)
			} else {
				m.Priority = v
			}
		case 22: // HealthStatus (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'health_status' (tag=22), expected 2 (length-delimited)", wt)
			}
			var mm ClusterHealthStatus
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'health_status' (tag=22): %w", err)
			}
			m.HealthStatus = &mm
		case 23: // SlimCollector (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'slim_collector' (tag=23), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'slim_collector' (tag=23): %w", err)
			} else {
				m.SlimCollector = v
			}
		case 24: // HelmConfig (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'helm_config' (tag=24), expected 2 (length-delimited)", wt)
			}
			var mm CompleteClusterConfig
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'helm_config' (tag=24): %w", err)
			}
			m.HelmConfig = &mm
		case 26: // MostRecentSensorId (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'most_recent_sensor_id' (tag=26), expected 2 (length-delimited)", wt)
			}
			var mm SensorDeploymentIdentification
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'most_recent_sensor_id' (tag=26): %w", err)
			}
			m.MostRecentSensorId = &mm
		case 28: // AuditLogState (map)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for map field 'audit_log_state' (tag=28), expected 2 (length-delimited)", wt)
			}

			if m.AuditLogState == nil {
				m.AuditLogState = make(map[string]*AuditLogFileState)
			}
			// consume the map entry size
			// TODO - should we validate this?
			if _, err = dec.DecodeInt32(); err != nil {
				return err
			}
			// always 2 values
			var (
				entryKey   string
				entryValue *AuditLogFileState
			)
			for i := 0; i < 2; i++ {
				etag, ewt, err := dec.DecodeTag()
				if err != nil {
					return err
				}
				switch etag {
				case 1: // key
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map key for field 'audit_log_state' (tag=28), expected 2 (length-delimited)", ewt)
					}
					if entryKey, err = dec.DecodeString(); err != nil {
						return err
					}
				case 2: // value
					if ewt != csproto.WireTypeLengthDelimited {
						return fmt.Errorf("incorrect wire type %v for map value for field 'audit_log_state' (tag=28), expected 2 (length-delimited)", ewt)
					}
					var v AuditLogFileState
					if err = dec.DecodeNested(&v); err != nil {
						return err
					} else {
						entryValue = &v
					}
				default:
					return fmt.Errorf("invalid map entry field tag %d, expected 1 or 2", etag)
				}
			}
			m.AuditLogState[entryKey] = entryValue
		case 29: // InitBundleId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'init_bundle_id' (tag=29), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'init_bundle_id' (tag=29): %w", err)
			} else {
				m.InitBundleId = s
			}

		case 30: // ManagedBy (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'managed_by' (tag=30), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'managed_by' (tag=30): %w", err)
			} else {
				m.ManagedBy = ManagerType(v)
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ClusterCertExpiryStatus

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ClusterCertExpiryStatus) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ClusterCertExpiryStatus) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ClusterCertExpiryStatus) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ClusterCertExpiryStatus) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ClusterStatus

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ClusterStatus) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// SensorVersion (string,optional)
	if l = len(m.SensorVersion); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ProviderMetadata (message,optional)
	if m.ProviderMetadata != nil {
		l = csproto.Size(m.ProviderMetadata)
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// OrchestratorMetadata (message,optional)
	if m.OrchestratorMetadata != nil {
		l = csproto.Size(m.OrchestratorMetadata)
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// UpgradeStatus (message,optional)
	if m.UpgradeStatus != nil {
		l = csproto.Size(m.UpgradeStatus)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CertExpiryStatus (message,optional)
	if m.CertExpiryStatus != nil {
		l = csproto.Size(m.CertExpiryStatus)
		sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ClusterStatus) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ClusterStatus) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// SensorVersion (1,string,optional)
	if len(m.SensorVersion) > 0 {
		enc.EncodeString(1, m.SensorVersion)
	}
	// ProviderMetadata (3,message,optional)
	if m.ProviderMetadata != nil {
		if err = enc.EncodeNested(3, m.ProviderMetadata); err != nil {
			return fmt.Errorf("unable to encode message data for field 'provider_metadata' (tag=3): %w", err)
		}
	}
	// OrchestratorMetadata (4,message,optional)
	if m.OrchestratorMetadata != nil {
		if err = enc.EncodeNested(4, m.OrchestratorMetadata); err != nil {
			return fmt.Errorf("unable to encode message data for field 'orchestrator_metadata' (tag=4): %w", err)
		}
	}
	// UpgradeStatus (5,message,optional)
	if m.UpgradeStatus != nil {
		if err = enc.EncodeNested(5, m.UpgradeStatus); err != nil {
			return fmt.Errorf("unable to encode message data for field 'upgrade_status' (tag=5): %w", err)
		}
	}
	// CertExpiryStatus (6,message,optional)
	if m.CertExpiryStatus != nil {
		if err = enc.EncodeNested(6, m.CertExpiryStatus); err != nil {
			return fmt.Errorf("unable to encode message data for field 'cert_expiry_status' (tag=6): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ClusterStatus) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // SensorVersion (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'sensor_version' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'sensor_version' (tag=1): %w", err)
			} else {
				m.SensorVersion = s
			}

		case 3: // ProviderMetadata (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'provider_metadata' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm ProviderMetadata
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'provider_metadata' (tag=3): %w", err)
			}
			m.ProviderMetadata = &mm
		case 4: // OrchestratorMetadata (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'orchestrator_metadata' (tag=4), expected 2 (length-delimited)", wt)
			}
			var mm OrchestratorMetadata
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'orchestrator_metadata' (tag=4): %w", err)
			}
			m.OrchestratorMetadata = &mm
		case 5: // UpgradeStatus (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'upgrade_status' (tag=5), expected 2 (length-delimited)", wt)
			}
			var mm ClusterUpgradeStatus
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'upgrade_status' (tag=5): %w", err)
			}
			m.UpgradeStatus = &mm
		case 6: // CertExpiryStatus (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'cert_expiry_status' (tag=6), expected 2 (length-delimited)", wt)
			}
			var mm ClusterCertExpiryStatus
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'cert_expiry_status' (tag=6): %w", err)
			}
			m.CertExpiryStatus = &mm

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ClusterUpgradeStatus

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ClusterUpgradeStatus) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Upgradability (enum,optional)
	if m.Upgradability != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.Upgradability))
	}
	// UpgradabilityStatusReason (string,optional)
	if l = len(m.UpgradabilityStatusReason); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// MostRecentProcess (message,optional)
	if m.MostRecentProcess != nil {
		l = csproto.Size(m.MostRecentProcess)
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ClusterUpgradeStatus) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ClusterUpgradeStatus) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Upgradability (1,enum,optional)
	if m.Upgradability != 0 {
		enc.EncodeInt32(1, int32(m.Upgradability))
	}
	// UpgradabilityStatusReason (2,string,optional)
	if len(m.UpgradabilityStatusReason) > 0 {
		enc.EncodeString(2, m.UpgradabilityStatusReason)
	}
	// MostRecentProcess (3,message,optional)
	if m.MostRecentProcess != nil {
		if err = enc.EncodeNested(3, m.MostRecentProcess); err != nil {
			return fmt.Errorf("unable to encode message data for field 'most_recent_process' (tag=3): %w", err)
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ClusterUpgradeStatus) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Upgradability (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'upgradability' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'upgradability' (tag=1): %w", err)
			} else {
				m.Upgradability = ClusterUpgradeStatus_Upgradability(v)
			}
		case 2: // UpgradabilityStatusReason (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'upgradability_status_reason' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'upgradability_status_reason' (tag=2): %w", err)
			} else {
				m.UpgradabilityStatusReason = s
			}

		case 3: // MostRecentProcess (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'most_recent_process' (tag=3), expected 2 (length-delimited)", wt)
			}
			var mm ClusterUpgradeStatus_UpgradeProcessStatus
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'most_recent_process' (tag=3): %w", err)
			}
			m.MostRecentProcess = &mm

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for UpgradeProgress

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *UpgradeProgress) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// UpgradeState (enum,optional)
	if m.UpgradeState != 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(m.UpgradeState))
	}
	// UpgradeStatusDetail (string,optional)
	if l = len(m.UpgradeStatusDetail); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *UpgradeProgress) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *UpgradeProgress) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// UpgradeState (1,enum,optional)
	if m.UpgradeState != 0 {
		enc.EncodeInt32(1, int32(m.UpgradeState))
	}
	// UpgradeStatusDetail (2,string,optional)
	if len(m.UpgradeStatusDetail) > 0 {
		enc.EncodeString(2, m.UpgradeStatusDetail)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *UpgradeProgress) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // UpgradeState (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'upgrade_state' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'upgrade_state' (tag=1): %w", err)
			} else {
				m.UpgradeState = UpgradeProgress_UpgradeState(v)
			}
		case 2: // UpgradeStatusDetail (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'upgrade_status_detail' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'upgrade_status_detail' (tag=2): %w", err)
			} else {
				m.UpgradeStatusDetail = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AuditLogFileState

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AuditLogFileState) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// LastAuditId (string,optional)
	if l = len(m.LastAuditId); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AuditLogFileState) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AuditLogFileState) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// LastAuditId (2,string,optional)
	if len(m.LastAuditId) > 0 {
		enc.EncodeString(2, m.LastAuditId)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AuditLogFileState) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 2: // LastAuditId (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'last_audit_id' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'last_audit_id' (tag=2): %w", err)
			} else {
				m.LastAuditId = s
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ClusterHealthStatus

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ClusterHealthStatus) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Id (string,optional)
	if l = len(m.Id); l > 0 {
		sz += csproto.SizeOfTagKey(9) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// CollectorHealthInfo (message,optional)
	if m.CollectorHealthInfo != nil {
		l = csproto.Size(m.CollectorHealthInfo)
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// AdmissionControlHealthInfo (message,optional)
	if m.AdmissionControlHealthInfo != nil {
		l = csproto.Size(m.AdmissionControlHealthInfo)
		sz += csproto.SizeOfTagKey(8) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// ScannerHealthInfo (message,optional)
	if m.ScannerHealthInfo != nil {
		l = csproto.Size(m.ScannerHealthInfo)
		sz += csproto.SizeOfTagKey(10) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// SensorHealthStatus (enum,optional)
	if m.SensorHealthStatus != 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(m.SensorHealthStatus))
	}
	// CollectorHealthStatus (enum,optional)
	if m.CollectorHealthStatus != 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(m.CollectorHealthStatus))
	}
	// OverallHealthStatus (enum,optional)
	if m.OverallHealthStatus != 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(m.OverallHealthStatus))
	}
	// AdmissionControlHealthStatus (enum,optional)
	if m.AdmissionControlHealthStatus != 0 {
		sz += csproto.SizeOfTagKey(7) + csproto.SizeOfVarint(uint64(m.AdmissionControlHealthStatus))
	}
	// ScannerHealthStatus (enum,optional)
	if m.ScannerHealthStatus != 0 {
		sz += csproto.SizeOfTagKey(11) + csproto.SizeOfVarint(uint64(m.ScannerHealthStatus))
	}
	// HealthInfoComplete (bool,optional)
	if m.HealthInfoComplete {
		sz += csproto.SizeOfTagKey(6) + 1
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ClusterHealthStatus) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ClusterHealthStatus) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Id (9,string,optional)
	if len(m.Id) > 0 {
		enc.EncodeString(9, m.Id)
	}
	// CollectorHealthInfo (1,message,optional)
	if m.CollectorHealthInfo != nil {
		if err = enc.EncodeNested(1, m.CollectorHealthInfo); err != nil {
			return fmt.Errorf("unable to encode message data for field 'collector_health_info' (tag=1): %w", err)
		}
	}
	// AdmissionControlHealthInfo (8,message,optional)
	if m.AdmissionControlHealthInfo != nil {
		if err = enc.EncodeNested(8, m.AdmissionControlHealthInfo); err != nil {
			return fmt.Errorf("unable to encode message data for field 'admission_control_health_info' (tag=8): %w", err)
		}
	}
	// ScannerHealthInfo (10,message,optional)
	if m.ScannerHealthInfo != nil {
		if err = enc.EncodeNested(10, m.ScannerHealthInfo); err != nil {
			return fmt.Errorf("unable to encode message data for field 'scanner_health_info' (tag=10): %w", err)
		}
	}
	// SensorHealthStatus (2,enum,optional)
	if m.SensorHealthStatus != 0 {
		enc.EncodeInt32(2, int32(m.SensorHealthStatus))
	}
	// CollectorHealthStatus (3,enum,optional)
	if m.CollectorHealthStatus != 0 {
		enc.EncodeInt32(3, int32(m.CollectorHealthStatus))
	}
	// OverallHealthStatus (4,enum,optional)
	if m.OverallHealthStatus != 0 {
		enc.EncodeInt32(4, int32(m.OverallHealthStatus))
	}
	// AdmissionControlHealthStatus (7,enum,optional)
	if m.AdmissionControlHealthStatus != 0 {
		enc.EncodeInt32(7, int32(m.AdmissionControlHealthStatus))
	}
	// ScannerHealthStatus (11,enum,optional)
	if m.ScannerHealthStatus != 0 {
		enc.EncodeInt32(11, int32(m.ScannerHealthStatus))
	}
	// HealthInfoComplete (6,bool,optional)
	if m.HealthInfoComplete {
		enc.EncodeBool(6, m.HealthInfoComplete)
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ClusterHealthStatus) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 9: // Id (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'id' (tag=9), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'id' (tag=9): %w", err)
			} else {
				m.Id = s
			}

		case 1: // CollectorHealthInfo (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'collector_health_info' (tag=1), expected 2 (length-delimited)", wt)
			}
			var mm CollectorHealthInfo
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'collector_health_info' (tag=1): %w", err)
			}
			m.CollectorHealthInfo = &mm
		case 8: // AdmissionControlHealthInfo (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'admission_control_health_info' (tag=8), expected 2 (length-delimited)", wt)
			}
			var mm AdmissionControlHealthInfo
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'admission_control_health_info' (tag=8): %w", err)
			}
			m.AdmissionControlHealthInfo = &mm
		case 10: // ScannerHealthInfo (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'scanner_health_info' (tag=10), expected 2 (length-delimited)", wt)
			}
			var mm ScannerHealthInfo
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'scanner_health_info' (tag=10): %w", err)
			}
			m.ScannerHealthInfo = &mm
		case 2: // SensorHealthStatus (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'sensor_health_status' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'sensor_health_status' (tag=2): %w", err)
			} else {
				m.SensorHealthStatus = ClusterHealthStatus_HealthStatusLabel(v)
			}
		case 3: // CollectorHealthStatus (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'collector_health_status' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'collector_health_status' (tag=3): %w", err)
			} else {
				m.CollectorHealthStatus = ClusterHealthStatus_HealthStatusLabel(v)
			}
		case 4: // OverallHealthStatus (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'overall_health_status' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'overall_health_status' (tag=4): %w", err)
			} else {
				m.OverallHealthStatus = ClusterHealthStatus_HealthStatusLabel(v)
			}
		case 7: // AdmissionControlHealthStatus (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'admission_control_health_status' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'admission_control_health_status' (tag=7): %w", err)
			} else {
				m.AdmissionControlHealthStatus = ClusterHealthStatus_HealthStatusLabel(v)
			}
		case 11: // ScannerHealthStatus (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'scanner_health_status' (tag=11), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'scanner_health_status' (tag=11): %w", err)
			} else {
				m.ScannerHealthStatus = ClusterHealthStatus_HealthStatusLabel(v)
			}
		case 6: // HealthInfoComplete (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'health_info_complete' (tag=6), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'health_info_complete' (tag=6): %w", err)
			} else {
				m.HealthInfoComplete = v
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for CollectorHealthInfo

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *CollectorHealthInfo) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Version (string,optional)
	if l = len(m.Version); l > 0 {
		sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// StatusErrors (string,repeated)
	for _, sv := range m.StatusErrors {
		l = len(sv)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}

	// TotalDesiredPodsOpt (oneof)
	if m.TotalDesiredPodsOpt != nil {
		switch typedVal := m.TotalDesiredPodsOpt.(type) {
		case *CollectorHealthInfo_TotalDesiredPods: // total_desired_pods (2,int32)
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(typedVal.TotalDesiredPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// TotalReadyPodsOpt (oneof)
	if m.TotalReadyPodsOpt != nil {
		switch typedVal := m.TotalReadyPodsOpt.(type) {
		case *CollectorHealthInfo_TotalReadyPods: // total_ready_pods (3,int32)
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(typedVal.TotalReadyPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// TotalRegisteredNodesOpt (oneof)
	if m.TotalRegisteredNodesOpt != nil {
		switch typedVal := m.TotalRegisteredNodesOpt.(type) {
		case *CollectorHealthInfo_TotalRegisteredNodes: // total_registered_nodes (4,int32)
			sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(typedVal.TotalRegisteredNodes))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *CollectorHealthInfo) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *CollectorHealthInfo) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Version (1,string,optional)
	if len(m.Version) > 0 {
		enc.EncodeString(1, m.Version)
	}
	// StatusErrors (5,string,repeated)
	for _, val := range m.StatusErrors {
		enc.EncodeString(5, val)
	}
	// TotalDesiredPodsOpt (oneof)

	if m.TotalDesiredPodsOpt != nil {
		switch typedVal := m.TotalDesiredPodsOpt.(type) {
		case *CollectorHealthInfo_TotalDesiredPods: // total_desired_pods (2,int32)
			enc.EncodeInt32(2, typedVal.TotalDesiredPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// TotalReadyPodsOpt (oneof)

	if m.TotalReadyPodsOpt != nil {
		switch typedVal := m.TotalReadyPodsOpt.(type) {
		case *CollectorHealthInfo_TotalReadyPods: // total_ready_pods (3,int32)
			enc.EncodeInt32(3, typedVal.TotalReadyPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// TotalRegisteredNodesOpt (oneof)

	if m.TotalRegisteredNodesOpt != nil {
		switch typedVal := m.TotalRegisteredNodesOpt.(type) {
		case *CollectorHealthInfo_TotalRegisteredNodes: // total_registered_nodes (4,int32)
			enc.EncodeInt32(4, typedVal.TotalRegisteredNodes)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *CollectorHealthInfo) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Version (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'version' (tag=1), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'version' (tag=1): %w", err)
			} else {
				m.Version = s
			}

		case 5: // StatusErrors (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'status_errors' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'status_errors' (tag=5): %w", err)
			} else {
				m.StatusErrors = append(m.StatusErrors, s)
			}

		case 2: // total_desired_pods_opt.total_desired_pods (oneof,int32)
			var ov CollectorHealthInfo_TotalDesiredPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_desired_pods' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_desired_pods' (tag=2): %w", err)
			} else {
				ov.TotalDesiredPods = v
			}
			m.TotalDesiredPodsOpt = &ov
		case 3: // total_ready_pods_opt.total_ready_pods (oneof,int32)
			var ov CollectorHealthInfo_TotalReadyPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_ready_pods' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_ready_pods' (tag=3): %w", err)
			} else {
				ov.TotalReadyPods = v
			}
			m.TotalReadyPodsOpt = &ov
		case 4: // total_registered_nodes_opt.total_registered_nodes (oneof,int32)
			var ov CollectorHealthInfo_TotalRegisteredNodes
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_registered_nodes' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_registered_nodes' (tag=4): %w", err)
			} else {
				ov.TotalRegisteredNodes = v
			}
			m.TotalRegisteredNodesOpt = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for AdmissionControlHealthInfo

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *AdmissionControlHealthInfo) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// StatusErrors (string,repeated)
	for _, sv := range m.StatusErrors {
		l = len(sv)
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}

	// TotalDesiredPodsOpt (oneof)
	if m.TotalDesiredPodsOpt != nil {
		switch typedVal := m.TotalDesiredPodsOpt.(type) {
		case *AdmissionControlHealthInfo_TotalDesiredPods: // total_desired_pods (1,int32)
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(typedVal.TotalDesiredPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// TotalReadyPodsOpt (oneof)
	if m.TotalReadyPodsOpt != nil {
		switch typedVal := m.TotalReadyPodsOpt.(type) {
		case *AdmissionControlHealthInfo_TotalReadyPods: // total_ready_pods (2,int32)
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(typedVal.TotalReadyPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *AdmissionControlHealthInfo) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *AdmissionControlHealthInfo) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// StatusErrors (3,string,repeated)
	for _, val := range m.StatusErrors {
		enc.EncodeString(3, val)
	}
	// TotalDesiredPodsOpt (oneof)

	if m.TotalDesiredPodsOpt != nil {
		switch typedVal := m.TotalDesiredPodsOpt.(type) {
		case *AdmissionControlHealthInfo_TotalDesiredPods: // total_desired_pods (1,int32)
			enc.EncodeInt32(1, typedVal.TotalDesiredPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// TotalReadyPodsOpt (oneof)

	if m.TotalReadyPodsOpt != nil {
		switch typedVal := m.TotalReadyPodsOpt.(type) {
		case *AdmissionControlHealthInfo_TotalReadyPods: // total_ready_pods (2,int32)
			enc.EncodeInt32(2, typedVal.TotalReadyPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *AdmissionControlHealthInfo) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {

		case 3: // StatusErrors (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'status_errors' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'status_errors' (tag=3): %w", err)
			} else {
				m.StatusErrors = append(m.StatusErrors, s)
			}

		case 1: // total_desired_pods_opt.total_desired_pods (oneof,int32)
			var ov AdmissionControlHealthInfo_TotalDesiredPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_desired_pods' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_desired_pods' (tag=1): %w", err)
			} else {
				ov.TotalDesiredPods = v
			}
			m.TotalDesiredPodsOpt = &ov
		case 2: // total_ready_pods_opt.total_ready_pods (oneof,int32)
			var ov AdmissionControlHealthInfo_TotalReadyPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_ready_pods' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_ready_pods' (tag=2): %w", err)
			} else {
				ov.TotalReadyPods = v
			}
			m.TotalReadyPodsOpt = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ScannerHealthInfo

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ScannerHealthInfo) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// StatusErrors (string,repeated)
	for _, sv := range m.StatusErrors {
		l = len(sv)
		sz += csproto.SizeOfTagKey(5) + csproto.SizeOfVarint(uint64(l)) + l
	}

	// TotalDesiredAnalyzerPodsOpt (oneof)
	if m.TotalDesiredAnalyzerPodsOpt != nil {
		switch typedVal := m.TotalDesiredAnalyzerPodsOpt.(type) {
		case *ScannerHealthInfo_TotalDesiredAnalyzerPods: // total_desired_analyzer_pods (1,int32)
			sz += csproto.SizeOfTagKey(1) + csproto.SizeOfVarint(uint64(typedVal.TotalDesiredAnalyzerPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// TotalReadyAnalyzerPodsOpt (oneof)
	if m.TotalReadyAnalyzerPodsOpt != nil {
		switch typedVal := m.TotalReadyAnalyzerPodsOpt.(type) {
		case *ScannerHealthInfo_TotalReadyAnalyzerPods: // total_ready_analyzer_pods (2,int32)
			sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(typedVal.TotalReadyAnalyzerPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// TotalDesiredDbPodsOpt (oneof)
	if m.TotalDesiredDbPodsOpt != nil {
		switch typedVal := m.TotalDesiredDbPodsOpt.(type) {
		case *ScannerHealthInfo_TotalDesiredDbPods: // total_desired_db_pods (3,int32)
			sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(typedVal.TotalDesiredDbPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// TotalReadyDbPodsOpt (oneof)
	if m.TotalReadyDbPodsOpt != nil {
		switch typedVal := m.TotalReadyDbPodsOpt.(type) {
		case *ScannerHealthInfo_TotalReadyDbPods: // total_ready_db_pods (4,int32)
			sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(typedVal.TotalReadyDbPods))
		default:
			_ = typedVal // ensure no unused variable
		}
	}

	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ScannerHealthInfo) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ScannerHealthInfo) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// StatusErrors (5,string,repeated)
	for _, val := range m.StatusErrors {
		enc.EncodeString(5, val)
	}
	// TotalDesiredAnalyzerPodsOpt (oneof)

	if m.TotalDesiredAnalyzerPodsOpt != nil {
		switch typedVal := m.TotalDesiredAnalyzerPodsOpt.(type) {
		case *ScannerHealthInfo_TotalDesiredAnalyzerPods: // total_desired_analyzer_pods (1,int32)
			enc.EncodeInt32(1, typedVal.TotalDesiredAnalyzerPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// TotalReadyAnalyzerPodsOpt (oneof)

	if m.TotalReadyAnalyzerPodsOpt != nil {
		switch typedVal := m.TotalReadyAnalyzerPodsOpt.(type) {
		case *ScannerHealthInfo_TotalReadyAnalyzerPods: // total_ready_analyzer_pods (2,int32)
			enc.EncodeInt32(2, typedVal.TotalReadyAnalyzerPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// TotalDesiredDbPodsOpt (oneof)

	if m.TotalDesiredDbPodsOpt != nil {
		switch typedVal := m.TotalDesiredDbPodsOpt.(type) {
		case *ScannerHealthInfo_TotalDesiredDbPods: // total_desired_db_pods (3,int32)
			enc.EncodeInt32(3, typedVal.TotalDesiredDbPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	// TotalReadyDbPodsOpt (oneof)

	if m.TotalReadyDbPodsOpt != nil {
		switch typedVal := m.TotalReadyDbPodsOpt.(type) {
		case *ScannerHealthInfo_TotalReadyDbPods: // total_ready_db_pods (4,int32)
			enc.EncodeInt32(4, typedVal.TotalReadyDbPods)
		default:
			_ = typedVal // ensure no unused variable
		}
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ScannerHealthInfo) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {

		case 5: // StatusErrors (string,repeated)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'status_errors' (tag=5), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'status_errors' (tag=5): %w", err)
			} else {
				m.StatusErrors = append(m.StatusErrors, s)
			}

		case 1: // total_desired_analyzer_pods_opt.total_desired_analyzer_pods (oneof,int32)
			var ov ScannerHealthInfo_TotalDesiredAnalyzerPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_desired_analyzer_pods' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_desired_analyzer_pods' (tag=1): %w", err)
			} else {
				ov.TotalDesiredAnalyzerPods = v
			}
			m.TotalDesiredAnalyzerPodsOpt = &ov
		case 2: // total_ready_analyzer_pods_opt.total_ready_analyzer_pods (oneof,int32)
			var ov ScannerHealthInfo_TotalReadyAnalyzerPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_ready_analyzer_pods' (tag=2), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_ready_analyzer_pods' (tag=2): %w", err)
			} else {
				ov.TotalReadyAnalyzerPods = v
			}
			m.TotalReadyAnalyzerPodsOpt = &ov
		case 3: // total_desired_db_pods_opt.total_desired_db_pods (oneof,int32)
			var ov ScannerHealthInfo_TotalDesiredDbPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_desired_db_pods' (tag=3), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_desired_db_pods' (tag=3): %w", err)
			} else {
				ov.TotalDesiredDbPods = v
			}
			m.TotalDesiredDbPodsOpt = &ov
		case 4: // total_ready_db_pods_opt.total_ready_db_pods (oneof,int32)
			var ov ScannerHealthInfo_TotalReadyDbPods
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'total_ready_db_pods' (tag=4), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 value for field 'total_ready_db_pods' (tag=4): %w", err)
			} else {
				ov.TotalReadyDbPods = v
			}
			m.TotalReadyDbPodsOpt = &ov
		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}

//------------------------------------------------------------------------------
// Custom Protobuf size/marshal/unmarshal code for ClusterUpgradeStatus_UpgradeProcessStatus

// Size calculates and returns the size, in bytes, required to hold the contents of m using the Protobuf
// binary encoding.
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Size() int {
	// nil message is always 0 bytes
	if m == nil {
		return 0
	}
	// return cached size, if present
	if csz := int(atomic.LoadInt32(&m.sizeCache)); csz > 0 {
		return csz
	}
	// calculate and cache
	var sz, l int
	_ = l // avoid unused variable

	// Active (bool,optional)
	if m.Active {
		sz += csproto.SizeOfTagKey(1) + 1
	}
	// Id (string,optional)
	if l = len(m.Id); l > 0 {
		sz += csproto.SizeOfTagKey(2) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// TargetVersion (string,optional)
	if l = len(m.TargetVersion); l > 0 {
		sz += csproto.SizeOfTagKey(3) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// UpgraderImage (string,optional)
	if l = len(m.UpgraderImage); l > 0 {
		sz += csproto.SizeOfTagKey(4) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Progress (message,optional)
	if m.Progress != nil {
		l = csproto.Size(m.Progress)
		sz += csproto.SizeOfTagKey(6) + csproto.SizeOfVarint(uint64(l)) + l
	}
	// Type (enum,optional)
	if m.Type != 0 {
		sz += csproto.SizeOfTagKey(7) + csproto.SizeOfVarint(uint64(m.Type))
	}
	// cache the size so it can be re-used in Marshal()/MarshalTo()
	atomic.StoreInt32(&m.sizeCache, int32(sz))
	return sz
}

// Marshal converts the contents of m to the Protobuf binary encoding and returns the result or an error.
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Marshal() ([]byte, error) {
	siz := m.Size()
	if siz == 0 {
		return []byte{}, nil
	}
	buf := make([]byte, siz)
	err := m.MarshalTo(buf)
	return buf, err
}

// MarshalTo converts the contents of m to the Protobuf binary encoding and writes the result to dest.
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) MarshalTo(dest []byte) error {
	// nil message == no-op
	if m == nil {
		return nil
	}
	var (
		enc    = csproto.NewEncoder(dest)
		buf    []byte
		err    error
		extVal interface{}
	)
	// ensure no unused variables
	_ = enc
	_ = buf
	_ = err
	_ = extVal

	// Active (1,bool,optional)
	if m.Active {
		enc.EncodeBool(1, m.Active)
	}
	// Id (2,string,optional)
	if len(m.Id) > 0 {
		enc.EncodeString(2, m.Id)
	}
	// TargetVersion (3,string,optional)
	if len(m.TargetVersion) > 0 {
		enc.EncodeString(3, m.TargetVersion)
	}
	// UpgraderImage (4,string,optional)
	if len(m.UpgraderImage) > 0 {
		enc.EncodeString(4, m.UpgraderImage)
	}
	// Progress (6,message,optional)
	if m.Progress != nil {
		if err = enc.EncodeNested(6, m.Progress); err != nil {
			return fmt.Errorf("unable to encode message data for field 'progress' (tag=6): %w", err)
		}
	}
	// Type (7,enum,optional)
	if m.Type != 0 {
		enc.EncodeInt32(7, int32(m.Type))
	}
	return nil
}

// Unmarshal decodes a binary encoded Protobuf message from p and populates m with the result.
func (m *ClusterUpgradeStatus_UpgradeProcessStatus) Unmarshal(p []byte) error {
	m.Reset()
	if len(p) == 0 {
		return nil
	}
	dec := csproto.NewDecoder(p)
	for dec.More() {
		tag, wt, err := dec.DecodeTag()
		if err != nil {
			return err
		}
		switch tag {
		case 1: // Active (bool,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'active' (tag=1), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeBool(); err != nil {
				return fmt.Errorf("unable to decode boolean value for field 'active' (tag=1): %w", err)
			} else {
				m.Active = v
			}
		case 2: // Id (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'id' (tag=2), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'id' (tag=2): %w", err)
			} else {
				m.Id = s
			}

		case 3: // TargetVersion (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'target_version' (tag=3), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'target_version' (tag=3): %w", err)
			} else {
				m.TargetVersion = s
			}

		case 4: // UpgraderImage (string,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'upgrader_image' (tag=4), expected 2 (length-delimited)", wt)
			}
			if s, err := dec.DecodeString(); err != nil {
				return fmt.Errorf("unable to decode string value for field 'upgrader_image' (tag=4): %w", err)
			} else {
				m.UpgraderImage = s
			}

		case 6: // Progress (message,optional)
			if wt != csproto.WireTypeLengthDelimited {
				return fmt.Errorf("incorrect wire type %v for field 'progress' (tag=6), expected 2 (length-delimited)", wt)
			}
			var mm UpgradeProgress
			if err = dec.DecodeNested(&mm); err != nil {
				return fmt.Errorf("unable to decode message value for field 'progress' (tag=6): %w", err)
			}
			m.Progress = &mm
		case 7: // Type (enum,optional)
			if wt != csproto.WireTypeVarint {
				return fmt.Errorf("incorrect wire type %v for tag field 'type' (tag=7), expected 0 (varint)", wt)
			}
			if v, err := dec.DecodeInt32(); err != nil {
				return fmt.Errorf("unable to decode int32 enum value for field 'type' (tag=7): %w", err)
			} else {
				m.Type = ClusterUpgradeStatus_UpgradeProcessStatus_UpgradeProcessType(v)
			}

		default:
			if skipped, err := dec.Skip(tag, wt); err != nil {
				return fmt.Errorf("invalid operation skipping tag %v: %w", tag, err)
			} else {
				m.unknownFields = append(m.unknownFields, skipped...)
			}
		}
	}
	return nil
}
